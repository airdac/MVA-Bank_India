list(support = 0.0001, confidence = 0.7, minlen=2, maxlen = 11))
good.rules2 <- subset(rules2, subset = lift > 3)
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
overdueRules2 <- subset(nonredundant2, subset =
(rhs %in% "target=overdue"))
# Note: even if there are good rules the support is too low, so if they exist,
# are very rare and, then, not useful to predict the people that did not pay
df.rules <- DATAFRAME(overdueRules2)
plot(sort(df.rules$support, decreasing = TRUE), type = "l", main = 'Rules with target = "overdue" in the rhs', ylab = 'Minimum support')
minor.tick(ny = 2, tick.ratio = 0.5)
abline(h=0.01, col="red", lty = 3, lwd = 2)
summary(overdueRules2)
inspect(overdueRules2, n=10)
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 2), by = "lift"))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 1)
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, by="lift"))
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 2), by = "lift"))
inspect(head(overdueRules3, by="lift"))
#plot(overdueRules3, measure = c("support", "lift"), shading = "confidence")
plot(overdueRules3, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 3), by = "lift"))
inspect(head(overdueRules3, by="lift"))
#plot(overdueRules3, measure = c("support", "lift"), shading = "confidence")
plot(overdueRules3, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
overdueRules3
inspect(overdueRules3)
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 3), by = "lift"))
inspect(head(overdueRules3, by="lift"))
#plot(overdueRules3, measure = c("support", "lift"), shading = "confidence")
plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
payedRules2 <- sort(subset(good.rules, subset = (lhs %in% "target=payed" & lift > 3)), by = "lift")
inspect(head(payedRules2, n=10, by="lift"))
# We can try to filter, removing "jobtype unknown" and "medicine" that are trivial rules
payedRules2 <- sort(subset(good.rules, subset = (lhs %in% "target=payed" & !(rhs %in% "job_type=Medicine") & !(rhs %in% "job_type=Jobtype_Unknown") & !(lhs %in% "job_type=Jobtype_Unknown") & lift > 3), by = "lift"))
inspect(head(payedRules2, n=10, by="lift"))
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 3), by = "lift"))
inspect(head(overdueRules3, by="lift"))
#plot(overdueRules3, measure = c("support", "lift"), shading = "confidence")
plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
summary(payedRules2)
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 3 & size <= 3), by = "lift"))
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 3 & maxlen <= 3), by = "lift"))
library(arules)
library("arulesViz")
library(dplyr)
library(ggplot2)
library(Hmisc)
dd <- read.table("2.Bank_India_preprocessed_data.csv",header=T, stringsAsFactors=TRUE, sep=",")
#Selecting categorical variables
dcat<-dd[,sapply(dd, is.factor)]
ecl = eclat(dtrans)
dtrans<-as(dcat, "transactions")
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo))
#Checking our transactional database
dtrans
inspect(head(dtrans,10))
summary(dtrans)
itemFrequencyPlot(dtrans, topN=10, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, support = 0.5, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, main ="Frequency of all itemsets", ylim = c(0,1))
ecl = eclat(dtrans)
size_eclat = size(ecl)
data.frame(size_eclat) %>%
ggplot(aes(x = size_eclat)) +
geom_histogram() +
labs(title = "ECLAT: Distribution of the size of the transactions",
x = "Size", y = "Frequency") +
theme_bw() +
scale_x_continuous(breaks = scales::pretty_breaks(n = 8))
# Chunk 1
# Clear plots
if(!is.null(dev.list())) dev.off()
# Clean workspace
rm(list=ls())
# Chunk 2
library(arules)
library("arulesViz")
library(dplyr)
library(ggplot2)
library(Hmisc)
dd <- read.table("2.Bank_India_preprocessed_data.csv",header=T, stringsAsFactors=TRUE, sep=",")
#Selecting categorical variables
dcat<-dd[,sapply(dd, is.factor)]
# Chunk 3
dtrans<-as(dcat, "transactions")
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo))
#Checking our transactional database
dtrans
inspect(head(dtrans,10))
summary(dtrans)
itemFrequencyPlot(dtrans, topN=10, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, support = 0.5, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, main ="Frequency of all itemsets", ylim = c(0,1))
# Chunk 4
ecl = eclat(dtrans)
size_eclat = size(ecl)
data.frame(size_eclat) %>%
ggplot(aes(x = size_eclat)) +
geom_histogram() +
labs(title = "ECLAT: Distribution of the size of the transactions",
x = "Size", y = "Frequency") +
theme_bw() +
scale_x_continuous(breaks = scales::pretty_breaks(n = 8))
# Chunk 1
# Clear plots
if(!is.null(dev.list())) dev.off()
# Clean workspace
rm(list=ls())
# Chunk 2
library(arules)
library("arulesViz")
library(dplyr)
library(ggplot2)
library(Hmisc)
dd <- read.table("2.Bank_India_preprocessed_data.csv",header=T, stringsAsFactors=TRUE, sep=",")
#Selecting categorical variables
dcat<-dd[,sapply(dd, is.factor)]
# Chunk 3
dtrans<-as(dcat, "transactions")
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo))
#Checking our transactional database
dtrans
inspect(head(dtrans,10))
summary(dtrans)
itemFrequencyPlot(dtrans, topN=10, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, support = 0.5, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, main ="Frequency of all itemsets", ylim = c(0,1))
# Chunk 4
ecl = eclat(dtrans)
size_eclat = size(ecl)
data.frame(size_eclat) %>%
ggplot(aes(x = size_eclat)) +
geom_histogram() +
labs(title = "ECLAT: Distribution of the size of the transactions",
x = "Size", y = "Frequency") +
theme_bw() +
scale_x_continuous(breaks = scales::pretty_breaks(n = 8))
# Chunk 5
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 1)
# Remove redundant rules
nonredundant <- good.rules[!is.redundant(good.rules),]
summary(nonredundant)
inspect(head(nonredundant,n=10, by="lift"))
length(good.rules)
length(nonredundant)
good.rules <- nonredundant
# Chunk 6
df.rules <- DATAFRAME(good.rules)
plot(sort(df.rules$support, decreasing = TRUE), type = "l", main = 'Rules and support', ylab = 'Minimum support')
minor.tick(ny = 2, tick.ratio = 0.5)
abline(h=0.01, col="red", lty = 3, lwd = 2)
# Chunk 7
# Note that setting an smaller support does not provide more good rules
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 3)
nonredundant <- good.rules[!is.redundant(good.rules),]
# Save the rules
# write.csv(DATAFRAME(nonredundant))
# Chunk 8
# Explore and plot the rules
library(colourvalues)
length(nonredundant)
# inspect(head(nonredundant, n=80, by="lift"))
plot(nonredundant, measure = c("support", "lift"), shading = "confidence", colors = c( 'red', 'blue', 'green'), interactive = FALSE)
# Chunk 9
pensioners = which(dcat$job_stat=="Pensioner")
unk_jobtype = which(dcat$job_type=="Jobtype_Unknown")
setdiff(pensioners, unk_jobtype)
setdiff(unk_jobtype, pensioners)
inspect(sort(good.rules, by="lift")[9:30,])
# Many rules associate people with unknown occupation and pensioners. Let's
# look at their setdiff()
unk_occupation <- which(dcat$occupation == "Occupation_Unknown")
setdiff(pensioners, unk_occupation)
setdiff(unk_occupation, pensioners)
length(setdiff(unk_occupation, pensioners))
# All pensioners declared their occupation as unknown. However, 675 individuals
# didn't tell their occupation and weren't pensioners.
# Chunk 10
unk.occup.not.pensioner <- subset(good.rules, subset =
lhs %in% "occupation=Occupation_Unknown" &
!(rhs %in% "job_stat=Pensioner") &
!(rhs %in% "job_type=Jobtype_Unknown"))
inspect(head(unk.occup.not.pensioner, n=10, by="lift"))
unk.occup.not.pensioner2 <- subset(good.rules, subset =
lhs %in% "occupation=Occupation_Unknown" &
!(rhs %in% "job_stat=Pensioner") &
!(rhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 1)
inspect(head(unk.occup.not.pensioner2, n=10, by="lift"))
# We'll try now to reverse the rules
unk.occup.not.pensioner3 <- subset(good.rules, subset =
rhs %in% "occupation=Occupation_Unknown" &
!(lhs %in% "job_stat=Pensioner") &
!(lhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 5)
inspect(head(unk.occup.not.pensioner2, n=10, by="lift"))
unk.occup.not.pensioner4 <- subset(good.rules, subset =
rhs %in% "occupation=Occupation_Unknown" &
!(lhs %in% "job_stat=Pensioner") &
!(lhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 4)
inspect(head(unk.occup.not.pensioner4, n=10, by="lift"))
# We can't describe in a confident and simple way the individuals with unknown
# occupation who aren't pensioners
# Chunk 11
# We'll study now the simplest rules
rules2 <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 2))
good.rules2 <- subset(rules2, subset = lift > 1)
inspect(head(good.rules2, n=10, by = "lift"))
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# Before doing any feature selection, let us remove redundant rules
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
summary(nonredundant2)
inspect(head(nonredundant2,n=10, by="lift"))
length(good.rules2)
length(nonredundant2)
good.rules2 <- nonredundant2
inspect(head(good.rules2, n=25, by="lift"))
# With these simple rules, we are able to describe better our individuals by
# gender and the jobs that make job_stat=Working up. Other categories we understand
# better now are car=N and studies = Secondary education.
# However, these rules are not relevant for our goals in this analysis. Moreover,
# none of them have a big lift value.
# Chunk 12
top10 <- sort(nonredundant, by="lift")[1:10]
plot(top10, method="grouped", shading = "lift")
# Chunk 13
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 1)
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, by="lift"))
# Chunk 14
# Plot the rules
plot(payedRules, measure=c("support", "confidence"), shading="lift",
main = 'Association rules (8266) with payers in the rhs') + theme(legend.position = "bottom")
# Chunk 15
payedRules2 <- sort(subset(good.rules, subset = (lhs %in% "target=payed" & lift > 3)), by = "lift")
inspect(head(payedRules2, n=10, by="lift"))
# We can try to filter, removing "jobtype unknown" and "medicine" that are trivial rules
payedRules2 <- sort(subset(good.rules, subset = (lhs %in% "target=payed" & !(rhs %in% "job_type=Medicine") & !(rhs %in% "job_type=Jobtype_Unknown") & !(lhs %in% "job_type=Jobtype_Unknown") & lift > 3), by = "lift"))
inspect(head(payedRules2, n=10, by="lift"))
# Chunk 16
plot(payedRules2, measure=c("support", "confidence"), shading="lift",
color = c('blue', 'lightblue'), main = 'Association rules (3570) with payers in the lhs') + theme(legend.position = "bottom")
# Chunk 17
overdueRules <- sort(subset(good.rules, subset = rhs %in% "target=overdue"), by = "lift")
summary(overdueRules) # No rules
# Chunk 18
# Note that setting an smaller support does not provide more good rules
rules2 <- apriori(dtrans, parameter =
list(support = 0.0001, confidence = 0.7, minlen=2, maxlen = 11))
good.rules2 <- subset(rules2, subset = lift > 3)
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
overdueRules2 <- subset(nonredundant2, subset =
(rhs %in% "target=overdue"))
# Note: even if there are good rules the support is too low, so if they exist,
# are very rare and, then, not useful to predict the people that did not pay
# Chunk 19
df.rules <- DATAFRAME(overdueRules2)
plot(sort(df.rules$support, decreasing = TRUE), type = "l", main = 'Rules with target = "overdue" in the rhs', ylab = 'Minimum support')
minor.tick(ny = 2, tick.ratio = 0.5)
abline(h=0.01, col="red", lty = 3, lwd = 2)
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 2), by = "lift"))
inspect(head(overdueRules3, by="lift"))
overdueRules3 <- sort(subset(good.rules2, subset = (lhs %in% "target=overdue" &
lift > 2), by = "lift"))
inspect(head(overdueRules3, by="lift"))
# We'll study now the simplest rules
rules2 <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 2))
good.rules2 <- subset(rules2, subset = lift > 1)
inspect(head(good.rules2, n=10, by = "lift"))
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# We'll study now the simplest rules
rules2 <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 2))
good.rules2 <- subset(rules2, subset = lift > 1)
inspect(head(good.rules2, n=10, by = "lift"))
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# Before doing any feature selection, let us remove redundant rules
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
summary(nonredundant2)
inspect(head(nonredundant2,n=10, by="lift"))
length(good.rules2)
length(nonredundant2)
good.rules2 <- nonredundant2
inspect(head(good.rules2, n=25, byE="lift"))
# With these simple rules, we are able to describe better our individuals by
# gender and the jobs that make job_stat=Working up. Other categories we understand
# better now are car=N and studies = Secondary education.
# However, these rules are not relevant for our goals in this analysis. Moreover,
# none of them have a big lift value.
rules2 <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 4))
good.rules2 <- subset(rules2, subset = lift > 2)
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# Before doing any feature selection, let us remove redundant rules
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
summary(nonredundant2)
inspect(head(nonredundant2,n=10, by="lift"))
# We'll study now the simplest rules
rules2 <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 2))
good.rules2 <- subset(rules2, subset = lift > 1)
inspect(head(good.rules2, n=10, by = "lift"))
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# Before doing any feature selection, let us remove redundant rules
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
summary(nonredundant2)
inspect(head(nonredundant2,n=10, by="lift"))
length(good.rules2)
length(nonredundant2)
good.rules2 <- nonredundant2
inspect(head(good.rules2, n=25, by="lift"))
# With these simple rules, we are able to describe better our individuals by
# gender and the jobs that make job_stat=Working up. Other categories we understand
# better now are car=N and studies = Secondary education.
# However, these rules are not relevant for our goals in this analysis. Moreover,
# none of them have a big lift value.
overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 3), by = "lift"))
inspect(head(overdueRules3, by="lift"))
#plot(overdueRules3, measure = c("support", "lift"), shading = "confidence")
plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 3))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
lift > 3), by = "lift"))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 3))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(overdueRules3, by="lift"))
#plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 3))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
#plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 3))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
#plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 2))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
#plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 2))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
#plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 2))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
#plot(payedRules2, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 2))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
plot(nonredundant, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 2))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
plot(nonredundant, method="graph", shading = "lift") + theme(plot.background = element_rect(fill='transparent', color=NA))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 2))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
plot(nonredundant, method="graph", shading = "lift") + theme_dark()
library(arules)
library("arulesViz")
library(dplyr)
library(ggplot2)
library(Hmisc)
dd <- read.table("2.Bank_India_preprocessed_data.csv",header=T, stringsAsFactors=TRUE, sep=",")
#Selecting categorical variables
dcat<-dd[,sapply(dd, is.factor)]
dtrans<-as(dcat, "transactions")
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo))
#Checking our transactional database
dtrans
inspect(head(dtrans,10))
summary(dtrans)
itemFrequencyPlot(dtrans, topN=10, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, support = 0.5, main ="Top 10 frequent itemsets", ylim = c(0,1))
itemFrequencyPlot(dtrans, main ="Frequency of all itemsets", ylim = c(0,1))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = (lhs %in% "target=overdue" &
lift > 2))
nonredundant <- good.rules[!is.redundant(good.rules),]
#overdueRules3 <- sort(subset(good.rules, subset = (lhs %in% "target=overdue" &
#                             lift > 3), by = "lift"))
inspect(head(nonredundant, by="lift"))
plot(nonredundant, method="graph", shading = "lift") + theme_dark()
plot(nonredundant, measure = c("support", "lift"), shading = "confidence", colors = c( 'red', 'blue', 'green'), interactive = FALSE)
plot(nonredundant, method="grouped", shading = "lift")
plot(nonredundant, method="grouped", shading = "lift", color = c("red", "green"))
plot(nonredundant, method="grouped", shading = "lift", color = c("red", "yellow"))
plot(nonredundant, method="grouped", shading = "lift", col = c("red", "yellow"))
plot(nonredundant, method="grouped", shading = "lift", col = c("green", "yellow"))
plot(nonredundant, method="grouped", shading = "lift", col = c("green", "orange"))
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green"))
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green"),
main = "Rules with overdue in the LHS")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green"))
+ labs(title= "Rules with overdue in the LHS")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green"))
+ theme(plot.title ="Rules with overdue in the LHS")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green")) + theme(plot.title ="Rules with overdue in the LHS")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green")) + ggtitle("Rules with overdue in the LHS")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green")) + ggtitle("Rules with overdue in the LHS") + ylab()
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green")) + ggtitle("Rules with overdue in the LHS") + ylab("")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green")) + ggtitle("Rules with overdue in the LHS") + ylab(" ")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green")) + ggtitle("Rules with overdue in the LHS") + xlab(" ")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green", "yellow")) + ggtitle("Rules with overdue in the LHS") + xlab(" ")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green", "pink")) + ggtitle("Rules with overdue in the LHS") + xlab(" ")
plot(nonredundant, method="grouped", shading = "lift", col = c("blue", "green", "pink", "gray")) + ggtitle("Rules with overdue in the LHS") + xlab(" ")
inspect(head(nonredundant, by="lift"))
summary(nonredundant)
inspect(head(nonredundant))
# Explore and plot the rules
library(colourvalues)
length(nonredundant)
# inspect(head(nonredundant, n=80, by="lift"))
plot(nonredundant, measure = c("support", "lift"), shading = "confidence", colors = c( 'red', 'blue', 'green'), interactive = FALSE)
# Explore and plot the rules
library(colourvalues)
length(nonredundant)
# inspect(head(nonredundant, n=80, by="lift"))
plot(nonredundant, measure = c("support", "lift"), shading = "confidence", colors = c( 'red', 'blue', 'green'), interactive = FALSE) +
theme(legend.position = "bottom")
top10 <- sort(nonredundant, by="lift")[1:10]
plot(top10, method="grouped", shading = "lift")
top10 <- sort(nonredundant, by="lift")[1:10]
plot(top10, method="grouped", shading = "lift", col = c("blue", "green"))
