dd.target.original <- dd[which(dd$target=='payed'),]
dd.target <- dd.target.original[sample(nrow(dd.target.original), nrow(dd.overdue)), ]
# EDA of the sample
create_report(dd.target)
# EDA of the original dataset
create_report(dd.target.original)
)
dd.balanced <- rbind(dd.overdue, dd.target)
summary(dd.balanced)
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 2)
inspect(head(good.rules, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant <- good.rules[!is.redundant(good.rules),]
summary(nonredundant)
inspect(head(nonredundant,n=10, by="lift"))
length(good.rules)
length(nonredundant)
inspect(head(good.rules, n=30, by="lift"))
# We will study now our target.
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, n=10, by="lift"))
payedRules2 <- sort(subset(good.rules, subset = lhs %in% "target=payed"), by = "lift")
inspect(head(payedRules2, n=10, by="lift"))
#payedRules3 <- sort(subset(good.rules, subset = lhs %in% "target=payed" &
#size(lhs) <= 2), by = "lift")
#inspect(head(payedRules3, n=10, by="lift"))
overdueRules <- sort(subset(good.rules, subset = rhs %in% "target=overdue"), by = "lift")
summary(overdueRules)
overdueRules2 <- sort(subset(good.rules, subset = lhs %in% "target=overdue"), by = "lift")
summary(overdueRules2)
overdueRules3 <- sort(subset(good.rules, subset = lhs %in% "target=overdue" &
size(lhs) <= 2), by = "lift")
inspect(head(overdueRules3, n=10, by="lift"))
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 1)
inspect(head(good.rules, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant <- good.rules[!is.redundant(good.rules),]
summary(nonredundant)
inspect(head(nonredundant,n=10, by="lift"))
length(good.rules)
length(nonredundant)
good.rules <- nonredundant
inspect(head(good.rules, n=30, by="lift"))
# We will study now our target.
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, n=10, by="lift"))
payedRules2 <- sort(subset(good.rules, subset = lhs %in% "target=payed"), by = "lift")
inspect(head(payedRules2, n=10, by="lift"))
#payedRules3 <- sort(subset(good.rules, subset = lhs %in% "target=payed" &
#size(lhs) <= 2), by = "lift")
#inspect(head(payedRules3, n=10, by="lift"))
overdueRules <- sort(subset(good.rules, subset = rhs %in% "target=overdue"), by = "lift")
summary(overdueRules)
overdueRules2 <- sort(subset(good.rules, subset = lhs %in% "target=overdue"), by = "lift")
summary(overdueRules2)
overdueRules3 <- sort(subset(good.rules, subset = lhs %in% "target=overdue" &
size(lhs) <= 2), by = "lift")
inspect(head(overdueRules3, n=10, by="lift"))
# We will study now our target.
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, n=10, by="lift"))
payedRules2 <- sort(subset(good.rules, subset = lhs %in% "target=payed"), by = "lift")
#payedRules3 <- sort(subset(good.rules, subset = lhs %in% "target=payed" &
#size(lhs) <= 2), by = "lift")
#inspect(head(payedRules3, n=10, by="lift"))
overdueRules <- sort(subset(good.rules, subset = rhs %in% "target=overdue"), by = "lift")
summary(overdueRules)
overdueRules2 <- sort(subset(good.rules, subset = lhs %in% "target=overdue"), by = "lift")
summary(overdueRules2)
overdueRules3 <- sort(subset(good.rules, subset = lhs %in% "target=overdue" &
size(lhs) <= 2), by = "lift")
inspect(head(overdueRules3, n=10, by="lift"))
summary(overdueRules3)
summary(good.rules)
dcat<-dd[,sapply(dd, is.factor)]
dtrans<-as(dcat, "transactions")
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 1)
inspect(head(good.rules, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant <- good.rules[!is.redundant(good.rules),]
summary(nonredundant)
inspect(head(nonredundant,n=10, by="lift"))
length(good.rules)
length(nonredundant)
good.rules <- nonredundant
inspect(head(good.rules, n=30, by="lift"))
# We will study now our target.
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, n=10, by="lift"))
# Too low lifts
payedRules2 <- sort(subset(good.rules, subset = lhs %in% "target=payed"), by = "lift")
inspect(head(payedRules2, n=10, by="lift"))
#size(lhs) <= 2), by = "lift")
payedRules3 <- sort(subset(good.rules, subset = lhs %in% "target=payed" &
size(lhs) <= 2), by = "lift")
inspect(head(payedRules3, n=10, by="lift"))
overdueRules <- sort(subset(good.rules, subset = rhs %in% "target=overdue"), by = "lift")
summary(overdueRules)
overdueRules2 <- sort(subset(good.rules, subset = lhs %in% "target=overdue"), by = "lift")
summary(overdueRules2)
overdueRules3 <- sort(subset(good.rules, subset = lhs %in% "target=overdue" &
size(lhs) <= 2), by = "lift")
summary(overdueRules3)
inspect(head(overdueRules3, n=10, by="lift"))
# Clear plots
if(!is.null(dev.list())) dev.off()
# Clean workspace
rm(list=ls())
#library of Association rules
library(arules)
library("arulesViz")
#some databases that are in form of transactions --> Read arules pdf users instructions
#setwd your own working directory to import the database
#How to work with associations rules with data matrix
dd <- read.table("2.Bank_India_preprocessed_data.csv",header=T, stringsAsFactors=TRUE, sep=",")
#Selecting categorical variables
dcat<-dd[,sapply(dd, is.factor)]
#Transforming our table as a transactional database
dtrans<-as(dcat, "transactions")
#[1] 5
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo))
#Checking our transactional database
dtrans
inspect(head(dtrans,10))
summary(dtrans)
itemFrequencyPlot(dtrans, topN=5)
itemFrequencyPlot(dtrans, support = 0.3)
itemFrequencyPlot(dtrans, support = 0.3)
itemFrequencyPlot(dtrans, support = 0.3)
# Clear plots
if(!is.null(dev.list())) dev.off()
# Clean workspace
rm(list=ls())
#library of Association rules
library(arules)
library("arulesViz")
dd <- read.table("2.Bank_India_preprocessed_data.csv",header=T, stringsAsFactors=TRUE, sep=",")
#Selecting categorical variables
dcat<-dd[,sapply(dd, is.factor)]
dtrans<-as(dcat, "transactions")
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo))
#Checking our transactional database
dtrans
inspect(head(dtrans,10))
summary(dtrans)
itemFrequencyPlot(dtrans, topN=5)
itemFrequencyPlot(dtrans, support = 0.3)
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 1)
inspect(head(good.rules, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant <- good.rules[!is.redundant(good.rules),]
summary(nonredundant)
inspect(head(nonredundant,n=10, by="lift"))
length(good.rules)
length(nonredundant)
good.rules <- nonredundant
pensioners = which(dcat$job_stat=="Pensioner")
unk_jobtype = which(dcat$job_type=="Jobtype_Unknown")
setdiff(pensioners, unk_jobtype)
setdiff(unk_jobtype, pensioners)
inspect(sort(good.rules, by="lift")[9:30,])
unk_occupation <- which(dcat$occupation == "Occupation_Unknown")
setdiff(pensioners, unk_occupation)
setdiff(unk_occupation, pensioners)
length(setdiff(unk_occupation, pensioners))
# Now we will analyze the category unk_occupation.
unk.occup.not.pensioner <- subset(good.rules, subset =
lhs %in% "occupation=Occupation_Unknown" &
!(rhs %in% "job_stat=Pensioner") &
!(rhs %in% "job_type=Jobtype_Unknown"))
inspect(head(unk.occup.not.pensioner, n=10, by="lift"))
unk.occup.not.pensioner2 <- subset(good.rules, subset =
lhs %in% "occupation=Occupation_Unknown" &
!(rhs %in% "job_stat=Pensioner") &
!(rhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 1)
inspect(head(unk.occup.not.pensioner2, n=10, by="lift"))
# We'll try now to reverse the rules
unk.occup.not.pensioner3 <- subset(good.rules, subset =
rhs %in% "occupation=Occupation_Unknown" &
!(lhs %in% "job_stat=Pensioner") &
!(lhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 5)
inspect(head(unk.occup.not.pensioner2, n=10, by="lift"))
unk.occup.not.pensioner4 <- subset(good.rules, subset =
rhs %in% "occupation=Occupation_Unknown" &
!(lhs %in% "job_stat=Pensioner") &
!(lhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 4)
inspect(head(unk.occup.not.pensioner4, n=10, by="lift"))
# We'll study nowthe simplest rules
rules2 <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 2))
good.rules2 <- subset(rules2, subset = lift > 1)
inspect(head(good.rules2, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
summary(nonredundant2)
inspect(head(nonredundant2,n=10, by="lift"))
length(good.rules2)
length(nonredundant2)
good.rules2 <- nonredundant2
inspect(head(good.rules2, n=25, by="lift"))
# We will study now our target.
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, n=10, by="lift"))
payedRules2 <- sort(subset(good.rules, subset = lhs %in% "target=payed"), by = "lift")
inspect(head(payedRules2, n=10, by="lift"))
payedRules3 <- sort(subset(good.rules, subset = lhs %in% "target=payed" &
size(lhs) <= 2), by = "lift")
inspect(head(payedRules3, n=10, by="lift"))
overdueRules <- sort(subset(good.rules, subset = rhs %in% "target=overdue"), by = "lift")
summary(overdueRules)
overdueRules2 <- sort(subset(good.rules, subset = lhs %in% "target=overdue"), by = "lift")
summary(overdueRules2)
overdueRules3 <- sort(subset(good.rules, subset = lhs %in% "target=overdue" &
size(lhs) <= 2), by = "lift")
inspect(head(overdueRules3, n=10, by="lift"))
#ruleInduction() !!!
## Display the 5 itemsets with the highest support.
orderedItemsets <- sort(eclatDTrans)
#ruleInduction() !!!
## Display the 5 itemsets with the highest support.
orderedItemsets <- sort(good.rules)
inspect(orderedItemsets)
## Get the itemsets as a list
as(items(top5), "list")
top5 <- sort(eclatDTrans)[1:5]
## Get the itemsets as a list
as(items(top5), "list")
top5 <- sort(eclatDTrans)[1:5]
top5 <- sort(good.rules)[1:5]
## Get the itemsets as a list
as(items(top5), "list")
## Get the itemsets as a binary matrix
as(items(top5), "matrix")
## Get the itemsets as a sparse matrix, a ngCMatrix from package Matrix.
## Warning: for efficiency reasons, the ngCMatrix you get is transposed
as(items(top5), "ngCMatrix")
###Visualizing Results
plot(good.rules, measure = c("support", "lift"), shading = "confidence")
#order == number of items inside the rules
plot(rulesDtrans, method = "two-key plot")
#order == number of items inside the rules
plot(good.rules, method = "two-key plot")
plot(good.rules, method = "grouped")
plot(good.rules, method = "paracoord")
plot(good.rules, method = "paracoord")
rules.bsup <- apriori(dtrans, parameter =
list(support = 0.1, confidence = 0.7, minlen=2, maxlen = 11))
good.rules.bsup <- subset(rules.bsup, subset = lift > 1)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant <- good.rules.bsup[!is.redundant(good.rules),]
inspect(head(nonredundant.bsup,n=10, by="lift"))
length(good.rules.bsup)
length(nonredundant.bsup)
good.rules <- nonredundant.bsup
rules.bsup <- apriori(dtrans, parameter =
list(support = 0.1, confidence = 0.7, minlen=2, maxlen = 11))
good.rules.bsup <- subset(rules.bsup, subset = lift > 1)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant <- good.rules.bsup[!is.redundant(good.rules),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
rules.bsup <- apriori(dtrans, parameter =
list(support = 0.1, confidence = 0.7, minlen=2, maxlen = 11))
good.rules.bsup <- subset(rules.bsup, subset = lift > 1)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules),]
summary(nonredundant.bsup)
rules.bsup <- apriori(dtrans, parameter =
list(support = 0.1, confidence = 0.7, minlen=2, maxlen = 11))
good.rules.bsup <- subset(rules.bsup, subset = lift > 1)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules.bsup),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
length(good.rules.bsup)
length(nonredundant.bsup)
good.rules.bsup <- nonredundant.bsup
plot(good.rules, method = "paracoord")
plot(good.rules.bsup, method = "paracoord")
# TOO SLOW  plot(good.rules, method = "paracoord")
# We will try to make the plot with less rules increasing the support
rules.bsup <- apriori(dtrans, parameter =
list(support = 0.25, confidence = 0.7, minlen=2, maxlen = 11))
good.rules.bsup <- subset(rules.bsup, subset = lift > 1)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules.bsup),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
good.rules.bsup <- subset(rules.bsup, subset = lift > 3)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules.bsup),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
length(good.rules.bsup)
length(nonredundant.bsup)
good.rules.bsup <- nonredundant.bsup
plot(good.rules.bsup, method = "paracoord")
good.rules.bsup <- subset(rules.bsup, subset = lift > 2)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules.bsup),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
length(good.rules.bsup)
length(nonredundant.bsup)
good.rules.bsup <- nonredundant.bsup
plot(good.rules, method="graph", interactive = "FALSE", shading = "lift")
plot(good.rules, method="graph", interactive = FALSE, shading = "lift")
good.rules.bsup <- subset(rules.bsup, subset = lift > 3)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules.bsup),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
length(good.rules.bsup)
length(nonredundant.bsup)
good.rules.bsup <- nonredundant.bsup
plot(good.rules.bsup, method="graph", interactive = FALSE, shading = "lift")
good.rules.bsup <- subset(rules.bsup, subset = lift > 2)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules.bsup),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
length(good.rules.bsup)
length(nonredundant.bsup)
good.rules.bsup <- nonredundant.bsup
# Clear plots
if(!is.null(dev.list())) dev.off()
# Clean workspace
rm(list=ls())
#library of Association rules
library(arules)
library("arulesViz")
#some databases that are in form of transactions --> Read arules pdf users instructions
#setwd your own working directory to import the database
#How to work with associations rules with data matrix
dd <- read.table("2.Bank_India_preprocessed_data.csv",header=T, stringsAsFactors=TRUE, sep=",")
#Selecting categorical variables
dcat<-dd[,sapply(dd, is.factor)]
#Transforming our table as a transactional database
dtrans<-as(dcat, "transactions")
#[1] 5
foo<-function(x){length(levels(x))}
sum(sapply(dcat, foo))
#Checking our transactional database
dtrans
inspect(head(dtrans,10))
summary(dtrans)
itemFrequencyPlot(dtrans, topN=5)
itemFrequencyPlot(dtrans, support = 0.3)
# As we already knew, our target is unbalanced, so later we will rebalance
# our database to analyze the target.
#Apriori
#?apriori
#minlen : minimun number of items
rules <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules <- subset(rules, subset = lift > 1)
inspect(head(good.rules, n=10, by = "lift"))
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# Before doing any feature selection, let us remove redundant rules
nonredundant <- good.rules[!is.redundant(good.rules),]
summary(nonredundant)
inspect(head(nonredundant,n=10, by="lift"))
length(good.rules)
length(nonredundant)
good.rules <- nonredundant
# Most rules have turned out to be redundant
# All rules with a lift higher than 17 are trivial
# The most relevant rule is that the set of pensioners is exactly the set
# of people with job type unknown. Indeed:
pensioners = which(dcat$job_stat=="Pensioner")
unk_jobtype = which(dcat$job_type=="Jobtype_Unknown")
setdiff(pensioners, unk_jobtype)
setdiff(unk_jobtype, pensioners)
inspect(sort(good.rules, by="lift")[9:30,])
# Many rules associate people with unknown occupation and pensioners. Let's
# look at their setdiff()
unk_occupation <- which(dcat$occupation == "Occupation_Unknown")
setdiff(pensioners, unk_occupation)
setdiff(unk_occupation, pensioners)
length(setdiff(unk_occupation, pensioners))
# All pensioners declared their occupation as unknown. However, 675 individuals
# didn't tell their occupation and weren't pensioners.
# Now we will analyze the category unk_occupation.
unk.occup.not.pensioner <- subset(good.rules, subset =
lhs %in% "occupation=Occupation_Unknown" &
!(rhs %in% "job_stat=Pensioner") &
!(rhs %in% "job_type=Jobtype_Unknown"))
inspect(head(unk.occup.not.pensioner, n=10, by="lift"))
unk.occup.not.pensioner2 <- subset(good.rules, subset =
lhs %in% "occupation=Occupation_Unknown" &
!(rhs %in% "job_stat=Pensioner") &
!(rhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 1)
inspect(head(unk.occup.not.pensioner2, n=10, by="lift"))
# We'll try now to reverse the rules
unk.occup.not.pensioner3 <- subset(good.rules, subset =
rhs %in% "occupation=Occupation_Unknown" &
!(lhs %in% "job_stat=Pensioner") &
!(lhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 5)
inspect(head(unk.occup.not.pensioner2, n=10, by="lift"))
unk.occup.not.pensioner4 <- subset(good.rules, subset =
rhs %in% "occupation=Occupation_Unknown" &
!(lhs %in% "job_stat=Pensioner") &
!(lhs %in% "job_type=Jobtype_Unknown") &
size(lhs) <= 4)
inspect(head(unk.occup.not.pensioner4, n=10, by="lift"))
# We can't describe in a confident and simple way the individuals with unknown
# occupation who aren't pensioners
# We'll study nowthe simplest rules
rules2 <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 2))
good.rules2 <- subset(rules2, subset = lift > 1)
inspect(head(good.rules2, n=10, by = "lift"))
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# Before doing any feature selection, let us remove redundant rules
nonredundant2 <- good.rules2[!is.redundant(good.rules2),]
summary(nonredundant2)
inspect(head(nonredundant2,n=10, by="lift"))
length(good.rules2)
length(nonredundant2)
good.rules2 <- nonredundant2
inspect(head(good.rules2, n=25, by="lift"))
# With these simple rules, we are able to describe better our individuals by
# gender and the jobs that make job_stat=Working up. Other categories we understand
# better now are car=N and studies = Secondary education.
# However, these rules are not relevant for our goals in this analysis. Moreover,
# none of them have a big lift value.
# We will study now our target.
payedRules <- sort(subset(good.rules, subset = rhs %in% "target=payed"), by = "lift")
summary(payedRules)
inspect(head(payedRules, n=10, by="lift"))
payedRules2 <- sort(subset(good.rules, subset = lhs %in% "target=payed"), by = "lift")
inspect(head(payedRules2, n=10, by="lift"))
payedRules3 <- sort(subset(good.rules, subset = lhs %in% "target=payed" &
size(lhs) <= 2), by = "lift")
inspect(head(payedRules3, n=10, by="lift"))
overdueRules <- sort(subset(good.rules, subset = rhs %in% "target=overdue"), by = "lift")
summary(overdueRules)
overdueRules2 <- sort(subset(good.rules, subset = lhs %in% "target=overdue"), by = "lift")
summary(overdueRules2)
overdueRules3 <- sort(subset(good.rules, subset = lhs %in% "target=overdue" &
size(lhs) <= 2), by = "lift")
inspect(head(overdueRules3, n=10, by="lift"))
# We have not found any good rule, so we need to balance our dataset. We will do
# it in another script
###Visualizing Results
plot(good.rules, measure = c("support", "lift"), shading = "confidence")
#order == number of items inside the rules
plot(good.rules, method = "two-key plot")
plot(good.rules, method = "grouped")
# TOO SLOW  plot(good.rules, method = "paracoord")
# We will try to make the plot with less rules increasing the support
rules.bsup <- apriori(dtrans, parameter =
list(support = 0.01, confidence = 0.7, minlen=2, maxlen = 11))
good.rules.bsup <- subset(rules.bsup, subset = lift > 2)
inspect(head(good.rules.bsup, n=10, by = "lift"))
# Highest lift rules are trivial, since they relate people with the same
# occupation and job_type. This was expected because these variables tell a
# similar information
# Before doing any feature selection, let us remove redundant rules
nonredundant.bsup <- good.rules.bsup[!is.redundant(good.rules.bsup),]
summary(nonredundant.bsup)
inspect(head(nonredundant.bsup,n=10, by="lift"))
length(good.rules.bsup)
length(nonredundant.bsup)
good.rules.bsup <- nonredundant.bsup
# plot(good.rules.bsup, method = "paracoord")
plot(good.rules.bsup, method="graph", interactive = FALSE, shading = "lift")
top10 <- head(good.rules, n=10, by="lift")
plot(good.rules.bsup, method="graph", interactive = FALSE, shading = "lift")
plot(top10, method="graph", interactive = FALSE, shading = "lift")
plot(top10, method="graph", shading = "lift")
top10 <- sort(good.rules, by="lift")[9:30]
plot(top10, method="graph", shading = "lift")
top10 <- sort(good.rules, by="lift")[11:30]
plot(top10, method="graph", shading = "lift")
top10 <- sort(good.rules, by="lift")[11:15]
plot(top10, method="graph", shading = "lift")
top10 <- sort(good.rules2, by="lift")[1:10]
plot(top10, method="graph", shading = "lift")
